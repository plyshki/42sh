/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_42sh_struct.h                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: amatilda <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/06/17 12:06:23 by amatilda          #+#    #+#             */
/*   Updated: 2019/06/25 15:24:38 by amatilda         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef FT_42SH_STRUCT_H
# define FT_42SH_STRUCT_H

# include "pguitar/ft_42sh_pguitar_struct.h"

typedef struct				s_shield_out_42sh//Структура возврата сколько байт и символов
{
	size_t					count;
	size_t					count_litter;
}							t_shield_out_42sh;

typedef struct				s_past_sort_42sh//Стандартная структура для указания на начало конец и середину  списка листов
{
	void					*first;//Отвечает за то пустая структура или нет - поэтому и должна быть занулина
	void					*center;
	void					*last;
}							t_past_sort_42sh;

typedef struct				s_std_key_42sh//Стандартная структрура для листов на основе ключей - ключи используються для поиска - вначале должна быть
{
	char					*lp_key;//Указатель на на ключ// Не смотря ни на что все же имеет окончани на нольь, но на это палагаться не стоит
	size_t					key_count;//Количество байт хранящихся в key
	size_t					key_litter;//Количество букв хранящихся в key
	struct s_std_key_42sh	*prev;// должно быть зануленно
	struct s_std_key_42sh	*next;// должно быть зануленно/
}							t_std_key_42sh;

typedef struct				s_all_cmd_42sh//Структура листа - хранящего все команды как в виде файлоив из PATH так и встроенные команды - cd, clear ...
{
	t_std_key_42sh			std;//стандартная шапка- должна быть всегда вначале - для использования в поиске и добавлении в цепочку листов
	char					add_litter;//Дополнительный символ для вывода
	void					*path;//Указатель на путь к каталогу - освобождать не надо или указатель на функцию
	void					*path_hash;//Указатель на на команду из hash требуеться чиститть актуально при AUTO_TYPE_HASH_42SH
	size_t					count_cmd;//Сколько раз вызывалась внешняя команда// должно быть зануленно
	uint_fast8_t			b_type;//Указывает функция или приложение
	char					key[1];//Всегда в конце тем самым удобно ссылаться на ключ без лишней вазни
}							t_all_cmd_42sh;

typedef struct				s_env_42sh//Структура листа - хранящего все текущие переменные среды
{
	t_std_key_42sh			std;//стандартная шапка- должна быть всегда вначале - для использования в поиске и добавлении в цепочку листов
	char					*lp_value;//Указатель на на значение переменной // Не смотря ни на что все же имеет окончани на нольь общее с key
	size_t					value_count;//Количество байт хранящихся в lp_value
	size_t					value_litter;//Количество символов хранящихся в lp_value//Только для ${#name}
	uint_fast8_t			b_type;//ТИп переменной
	size_t					number;//Для цифровых типов иницилизируеться в зависимости от переменной//Для не цефровых количество в значении '\n'
	char					key[1];//Всегда в конце тем самым удобно ссылаться на ключ без лишней вазни
}							t_env_42sh;

typedef struct				s_slesh_42sh//Структура листа - хранящего все текущие переменные среды
{
	size_t					count;
	size_t					count_litter;
}							t_slesh_42sh;

typedef struct				s_in_42sh//Структура листа - хранящего все что связано с текущим в водом
{//лапухнулся надо было использовать unsigned char забылся что char это отрицательная единица да и си не assembler - изз-за этого проблемы с utf-8 поэтому придеться с помощью переназначений....
	char					*lp_current;//Указатель на следующую позицию в буффере
	char					*lp_b;//Указатель на буфер для считывания ввода пользователя
	size_t					max;//Размер выделенного буфера в байтах *lp_b
	size_t					count;//Количество записанных байт в *lp_b // должно быть зануленно
	size_t					count_litter;//Количество записанных букв в *lp_b // должно быть PRE_MSG_LITTER_42SH
	size_t					count_litter_current;//Количество записанных букв в *lp_b // должно быть PRE_MSG_LITTER_42SH
	struct s_in_42sh		*prev;// должно быть зануленно
	struct s_in_42sh		*next;// должно быть зануленно
	char					*lp_b_dup;//Указатель на буфер для считывания ввода пользователя - дубль
	size_t					max_dup;//Размер выделенного буфера в байтах *lp_b -  - дубль -// должно быть зануленно
	size_t					count_dup;//Количество записанных байт в *lp_b  - дубль
	size_t					count_litter_dup;//Количество записанных букв в *lp_b - дубль
	size_t					count_litter_current_dup;//Количество записанных букв в *lp_b - дубль
	size_t					slesh_current;//Текущий перевод строки
	size_t					slesh_max;//указывает максимальное число переводы строк
	size_t					slesh_max_dup;//указывает максимальное число переводы строк
	t_slesh_42sh			**spl_slesh;//указывает есть переводы строк// должно быть зануленно
	t_slesh_42sh			**spl_slesh_dup;//указывает есть переводы строк// - дубль
}							t_in_42sh;

typedef struct				s_in_main_42sh//Все что связанно явно с листами содержащие  информацию о вводимом тексте
{
	t_in_42sh				*in_current;//указатель на текущий лист с  введенным текстам
	t_in_42sh				*in_last;//Последний самый лист 
	t_in_42sh				*in_first;//Первый самый лист// должно быть зануленно
	uint_fast8_t			in_count;//Количество листов t_in_42sh // должно быть зануленно
}							t_in_main_42sh;

typedef struct				s_msg_42sh//Все что связанно явно с сообщениями например стартовое сообщение
{
	char					*pre_msg;//Указатель на стартовое сообщение
	char					*pre_msg_sp;//Указатель на стартовое сообщение в случаи сообщений не ведущих к завершению работы программы
	uint_fast8_t			pre_msg_litter;//Количество букв в стартовом сообщении
	char					*hrdc;//Приветвенное сообщение для хередока// должно быть зануленно
	size_t					hrdc_lit;//Сколько букв в приветсвенном сообщения хередока
}							t_msg_42sh;

typedef struct				s_env_main_42sh//Все что связанно явно с переменнами среды
{
	t_past_sort_42sh		root;//Центральный лист для листов переменных среды
	size_t					count_env;//Количество переменных сред // должно быть зануленно
	size_t					count_local;//Количество переменных локальных // должно быть зануленно
	t_env_42sh				*exit_status;//Лист - Хранит статус последнего действия
	t_env_42sh				*shell_pid;//Лист - Хранит pid текущей оболочки
	t_env_42sh				*last_pid;//Лист - Хранит pid последнего процесса в случае если в фоне запускаеться &
	unsigned char			*lp_end_exp;//В случае ${name:?value} хранит указатель на канец текущей после } ///во время автообновления
	size_t					n_exp;//Сколько нужно выделить под раскрыти если надо раскрывать//во время автообновления
	size_t					b_exp_err;//Указывает нужно ли закрывать в } и экранировать кавычки //Если ноль не надо// во время автообновления
	uint_fast8_t			offset_auto;//Указывает смещение что бы получить начало актуально в случае '{' //может быть 2 '${' и 3 '${#'
}							t_env_main_42sh;

typedef struct				s_pwd_42sh//Отвечает за все что с путями
{
	t_string				path;//путь к текущему каталогу
	t_string				prev_path;//путь к предыдущему  каталогу
	unsigned char			*path_view;//Указатель на путь к каталого уже экраниреванному// должно быть зануленно
	t_shield_out_42sh		sh_path_view;//Сколько букв и байт занимает - path_view// должно быть зануленно
	char					**spl_cd;//массив путей для cd береться из переменной среды EXP_CDPATH_42SH// должно быть зануленно
}							t_pwd_42sh;

typedef struct				s_pipe_42sh//Отвечает за перенаправление
{
	uint_fast16_t			b_flag;//Доп флаги типа закрыть или &
	int						fd_1;
	int						fd_2;
	void					*lp_heredok_b;//Указатель на heredok если << на строку в листе или выделеное и обоработаною памят
	void					*lp_heredok_e;//Указатель на конец heredok если << на строку в листе или выделеное и обоработаною памят//В случае с JOBS_HRDC_42SH тут размер сколько вывести байт нужно уже готового
	uint_fast8_t			b_heredok;//Указывает какие действия нужно выполнить с lp_heredok_b
}							t_pipe_42sh;

typedef struct				s_exp_set_42sh//Отвечает за локальные списки переменных сред которые нужно установить
{
	size_t					n;
	struct s_exp_set_42sh	*next;// должно быть зануленно если конец
	unsigned char			lp[1];//Будем хранить в конце
}							t_exp_set_42sh;

typedef struct				s_add_exp_42sh//Структура для добавление переменных локальных или среды
{
	void					*value;//Указатель на добавление
	void					*value_end;//Указатель на конец добавления
	uint_fast8_t			b_type;//ТИп переменной
}							t_add_exp_42sh;

typedef struct				s_exit_pars_42sh//Отвечает за то есть ли ошибка вынуждающая прервать все что напаршенно
{
	uint_fast8_t			error;//Указывает тип ошибки
	unsigned char			*lp;//Если ноль значит не было ошибки//Должно быть зануленно если
}							t_exit_pars_42sh;

typedef struct				s_jobs_42sh//Отвечает за процесс//Должна быть вся зануленна
{
	int						fds[(FD_MAX_SUPPORT_42SH + 1) * 2];//максимум открытых вазможных дескрипторов 10 - от 0 до 9
	pid_t					pipe_pid[FD_MAX_SUPPORT_42SH + 1];//+1 так как fd начинаеться с 0//У нас процессов может быть только не больше чем используемых fd//Хранит pid используемые для пипе//должно быть зануленно
	size_t					id;//id номер процесса//должно быть зануленно
	size_t					b_pipe_fd;//Для определения pid процессов перенаправления// b_fd_left b_fd_right//должно быть зануленно
	unsigned char			*cmd;//Команда отвечающая за данный jobs фришим
	int						stat_loc;//Статус который получили после waitpid//должно быть заннуленн//В случае функции статус выхода тут
	uint_fast8_t			count_pipes;//Количество pipes что нужно создать// должно быть зануленно
	uint_fast8_t			b_type;//Указывает функция или приложение
	uint_fast8_t			error;//Указывает тип ошибки для в случае если  AUTO_TYPE_ERROR_42SH
	size_t					b_flag_close;//Флаги определяющие все закрытые fd
	size_t					b_fd_left;//Хранит fd для записи в вприложение
	size_t					b_fd_right;//Хранит fd для записи из  вприложение в файл или другое приложение
	pid_t					pid;//Pid процесса если ноль значит функция которая без пайпа и не запускалась с помощью fork или уже завершился
	pid_t					pid_view;//Для отображения pid в утилите jobs, если ноль значит функция которая без пайпа и не запускалась с помощью fork//должно быть зануленно//Первый в паке это так же и pid группы кроме скрипта но там мы и не юзаем fg и bg
	size_t					count;//Число перед листов запущеных перед этим процессов если 1 тогда только один лист есть отвечающий за текущий запуск
	void					*path;//Если b_type == AUTO_TYPE_FUN_42SH - игнорим// иначе освобождаем если не ноль, если AUTO_TYPE_ERROR_42SH тогда сообщение об ошибки//иначе если не ноль  путь к папки приложения + имя команды с '/' между ними 
	char					**lp_arg;//Массив аргументав для запуска программ
	struct s_jobs_42sh		*prev;// должно быть зануленно
	struct s_jobs_42sh		*next;// должно быть зануленно/
	struct s_jobs_42sh		*prev_id;//Что бы сортировать id и не искать в n степени а только за один прроход//должно быть зануленно
	struct s_jobs_42sh		*next_id;//Что бы сортировать id и не искать в n степени а только за один прроход// должно быть зануленно/
	size_t					n;//Сколько папйпов или редиректов храниться если ноль - тогда нет их// должно быть зануленно
	int						fd_pipe;//Если ноль значит нет пайпа, если один значит пайп есть но его еще не открыли, иначе здесь fd конца пайпа для чтения
	t_exp_set_42sh			*exp_set;//Указатель на установку локальных переменных//должно быть зануленно
	t_exp_set_42sh			*exps_set;//Указатель на первую установленую  локальных переменных расшириную//должно быть зануленно
	t_exp_set_42sh			*exps_set_end;//Указатель на последнюю установленую  локальных переменных расшириную//должно быть зануленно
	size_t					exps_loop;//Контролирует в цикле или нет если ноль то только входим в его//должно быть зануленно
	t_exp_set_42sh			*exps_set_tmp;//Указатель на временную переменную для хранения списка, что бы перенестипотом в exps_set и тем самым порядок сохранить//должно быть зануленно
	t_pipe_42sh				pipe[1];//должно быть зануленно
}							t_jobs_42sh;

typedef struct				s_process_42sh//Отвечает за все что связанно с процессами
{
	unsigned char			*lp_cmd;//Указывает на начало команды что бы в jobs сохранить
	char					**lp_msg_sgnl;//Указатель на массив с сообщениями для сигналов
	t_jobs_42sh				*jobs_last;//сохраняеться перед началом парсинга самый последний что бы правильно определять пайп
	t_jobs_42sh				*jobs_cut;//Хранит вырезанные jobs которые при первой же вазможности нужно освободить//должно быть зануленно
	t_jobs_42sh				*jobs_current;//Если не ноль то хранит указатель на на чало обрабатываемого списка jobs//должно быть зануленно//Нужно для сигнала SIGCHLD//И что бы контролировать jobs_minus jobs_plus
	t_jobs_42sh				*jobs_minus;//Указывает на начало jobs который являеться перед текущим или ноль устанавливаеться имменно вызавом спец функции до этого не валидно
	t_jobs_42sh				*jobs_plus;//Указывает на начало jobs который являеться текущим или ноль устанавливаеться имменно вызавом спец функции до этого не валидно
	t_past_sort_42sh		jb;//Центральный лист для листов запущенных процессов//last - последний запущенный лист//first первый //central -не используеться
	t_past_sort_42sh		jb_id;//Центральный лист для подсчета id jobs что бы добавлялся по порядку
	pid_t					pid_main;//pid - текущей оболочки
	pid_t					pid_fork;//pid - fork
	int						even_fds[1 * 2];//ДЛя синхронизации с сигналом SIGCHLD//должно быть зануленно
	pid_t					pid_grup;//Главный pid текущей группы jobs находящейся на обработке
	uint_fast8_t			b_auto_view;//Если не ноль то не отображено id с pid всех процессов иначе выведенно//должно быть зануленно
	size_t					count_runing;//отображает количество запущенных в фоне процессов выводящих информацию//должно быть зануленно
	t_exit_pars_42sh		exit_pars;//Ошибка прерывающая обработку все что напаршено
}							t_process_42sh;

typedef struct				s_auto_42sh//Отвечает за все что связанно с авто дополнением
{
	t_past_sort_42sh		all_cmd;//Начало списка где храниться все команды доступные
	t_all_cmd_42sh			**spl_all_cmd;//Для удобства указатели на листы с командами засоваем в масив что бы по индексу обращаться к ним
	size_t					count_all;//Максимальное каличество команд// должно быть зануленно
	size_t					max_litter;//Максимальная длина всех команд в буквах// должно быть зануленно
	size_t					view_raw;//Количество столбиков при активном b_view, что бы знать перерисовывать или нет при изменении размеров терминала
	size_t					b_limit;//Если ноль - много команд при работе авто дополнеия нет - клавишу не блокируем, иначе - содержит отображенное количествво букв// должно быть зануленно
	size_t					b_auto;//Если ноль - список подсказок команд не выведен, иначе - содержит отображенное количествво букв// должно быть зануленно
	size_t					auto_cmd;//Максимальное количество елементов используемых из auto_spl
	size_t					auto_litter_len;//длина в буквах текущего элемента при переборе
	size_t					auto_len;//длина в байтах текущего элемента при переборе
	char					spec_sym;//пробел или косая / выводит// Для файлов auto_file только  и когда только один найден верный элемент
	uint_fast8_t			b_view;//Если ноль - нечего чистить на экране и никакия подсказки к командам не отобразились // должно быть зануленно
	t_all_cmd_42sh			**auto_spl;//указатель на  на начало перебора элементв из spl_all_cmd
	size_t					count_new_alias;//Счетчик были добавленны новые алиасы или нет сохраняем  count_all и пото сравниваем были ли изменения
}							t_auto_42sh;

typedef struct				s_select_42sh//Отвечает за все что связанно с выделением, копирование и вырезанием текста
{
	unsigned char			*b;//указатель на начало выделения, если ноль ничего не выделенно//должно быть зануленно
	unsigned char			*e;//Указатель на конец выделения
	size_t					count_litter;//количество букв выделенных
	void					*lp_clipboard;//Хранит содержимое локального буфера обмена если ноль ничего не сохранено// должно быть зануленно
	size_t					clipboard_count;//Количество байт в буфере обмена
}							t_select_42sh;

typedef struct				s_alias_42sh//Храним в виде листов места где вставили алиасы что бы повторно не обрабатывать и потом востановить то что было по умолчанию
{
	size_t					offset;//относительно начала буфера с текстом
	size_t					offset_end;//сколько занеили байт конец относительно начала буфера
	size_t					n;//Размер в байтах сколько занимает restore
	struct s_alias_42sh		*next;// должно быть зануленно
	unsigned char			restore[1];//Указатель на востанавливаемое
}							t_alias_42sh;

typedef struct				s_dq_42sh//Отвечает за все что связанно с добором текста в виде ковычек, heredoc и ...
{
	t_in_42sh				*in_dquote;//Когда включен  режим не завершенные кавычки - ссылка на выразенный лист в котором было включен данный режим
	unsigned char			dquote;//Указывает включен ли режим  - не завершенные кавычки // должно быть зануленно
	void					*hrdoc_cmp_lp;//Указатель на маллченный ключ для heredoc действует только в случае нажатия ctr + D и dquote = '<' // должно быть зануленно //нужго фришить если не ноль
	size_t					hrdoc_cmp_count;//Байт в указателе hrdoc_cmp_lp
	uint8_t					b_hrdoc;//DQ_HRDC_42SH и DQ_HRDC_ERR_42SH
	void					*hrdoc_next_lp;//Указатель на продолжение перебора heredoc
	size_t					hrdoc_next_slesh;//Индекс spl на продолжение перебора heredoc
	void					*hrdoc_start_lp;//Начало старта парсинга команд между переводами строк
	t_alias_42sh			*first_alias;// должно быть зануленно - если не ноль значит сохранены места где заменили алисы в тексе
	t_alias_42sh			*last_alias;//Указатель на последний лист сохраненого алиаса
	size_t					slesh_alias;// должно быть зануленно если не ноль в вставленных алисах есть переводы строк
}							t_dq_42sh;

typedef struct				s_sh_42sh//Отвечает за все что связанно с чтение из файла сценария
{
	char					**lp_arg;//Указательна на полученные аргументы ханим что бы зафришить потом
	unsigned char			*path;//Путь к скрипту // должно быть зануленно
	size_t					count_path;//Длинна в байтах скрипта
	unsigned char			*lp_sh;//Указатель на считанные данные из скрипта
	unsigned char			*lp_sh_e;//Указатель на конец считанных данных из скрипта
	unsigned char			*lp_cmd;//Указатель на начало считывания в парсерре для правильного вывода ошибки о столбце
}							t_sh_42sh;

typedef struct				s_logins_42sh//Хранит все логины системы
{
	t_std_key_42sh			std;//стандартная шапка- должна быть всегда вначале - для использования в поиске и добавлении в цепочку листов
	unsigned char			*home_dir;
	size_t					home_dir_count;
}							t_logins_42sh;

typedef struct				s_home_42sh//Хранит все что связанно с переменной среды HOME
{
	char					*lp_home;//путь к домашнему каталогу// должно быть зануленно
	size_t					count_home;//Сколько байт хоть и оканчиваеться на 0
	void					*lp_home_tmp_b;//указывает для переноса указателя по тексту
	void					*lp_home_tmp_e;//указывает для переноса указателя по тексту
	t_logins_42sh			*list;//Если ноль такого пользователя не нашли иначе указхатель на лист с ним
}							t_home_42sh;

typedef struct				s_main_42sh//Главная структура проекта
{
	t_pguitar_42sh			pguitar;
	t_dq_42sh				dq;
	t_process_42sh			pr;
	t_in_main_42sh			in;
	t_msg_42sh				msg;
	t_env_main_42sh			env;
	t_auto_42sh				auto_;
	t_auto_42sh				auto_file;
	t_auto_42sh				auto_env;
	t_select_42sh			slc;
	t_pwd_42sh				pwd;
	t_home_42sh				home;
	struct winsize			ws;
	t_sh_42sh				sh;
	t_past_sort_42sh		login;
	struct termios			tty;//Храним состояние терминала для востановление его состояния
	struct termios			tty_change;//Состояние терминала не конанического режима для установки данного режима
	t_auto_42sh				*lp_auto;//Указатель на текущее авто-дополнение
	char					**lp_spl_path;//Массив с путями к исполняемым файлам// должно быть зануленно
	uintmax_t				litter_save[1];//на сохранение хвоста utf-8 если при вставке он будет обрезан // должно быть зануленно
	uintmax_t				litter[BUFFER_LITTER_42SH];//Храним считываем клавиши сюда
	uint_fast8_t			b_signo;//Если не равно 0 значит находимся во время обработки сигнала // должно быть зануленно
	uint_fast8_t			b_read;//Если ноль то считывает по действиям иначе если не ноль то ограниченно по временни на считывание
	uint_fast8_t			b_hash;//По умолчанию HASH_NOT_42SH
	uint_fast8_t			b_quest_exit;// Если не ноль значит задали вопрос выходить или нет//Если == //должно быть зануленно
	uint_fast8_t			b_location;//Указывает в каком режиме работает оболочка для отдельных функци//должно быть зануленно
	int						b_tty_out_in;//Если запущенно в фоне прога тут записываем сигнал приостановивший нас // должно быть зануленно
	size_t					count_tty_out_in;//Если не ноль значит приостанавливались хоть один раз// должно быть зануленно
	t_write_buff			out;//Буфер для команд к терминалу что бы write не использовать слишком часто STDOUT_FILENO
	t_write_buff			err;//Буфер для ошибок что бы write не использовать слишком часто STDERR_FILENO
	size_t					b_fd_close;//Помогает определить закрыт ли данный fd или нет при вызове внутренних функций
	uint_fast8_t			b_mode;//Если ноль значит находимся в режиме теста и сможем тем самым пользоваться валгриндам иначе в режиме полной готовности и защиты))
	char					buff_err[BUFFER_ERR_42SH];//Буфер для t_write_buff			err
	char					buff_out[BUFFER_OUT_42SH];//Буфер для t_write_buff			out
	uint32_t				lp_crc32_mirror[CRC32_DEPTH_42SH * 0x100];//Таблица для crc32
}							t_main_42sh;

extern t_main_42sh			*g_lp_array;//Глобальный указатель на главную структурру

typedef struct				s_add_litter_42sh//Структура для добавление строки
{
	size_t					count;//Количетво байт добавляющихся
	size_t					count_litter;//Количество букв добавляющихся
	uint_fast8_t			correction;//Ничего
}							t_add_litter_42sh;

typedef struct				s_replase_in_pars_42sh//Структура для передачи параметров все изз-за долбанных норм
{
	unsigned char			*e;//добанная норма приходиться из-за нее клипать костыль на костыле//Чисто чтобы больше 5 переменых использовать//В нутри самой функции не юзаетьсться
	t_jobs_42sh				*jobs;//добанная норма приходиться из-за нее клипать костыль на костыле//Чисто чтобы больше 5 переменых использовать//В нутри самой функции не юзаетьсться
	size_t					pipe_count;//добанная норма приходиться из-за нее клипать костыль на костыле//Чисто чтобы больше 5 переменых использовать//В нутри самой функции не юзаетьсться
	unsigned char			*start;//добанная норма приходиться из-за нее клипать костыль на костыле//Чисто чтобы больше 5 переменых использовать//В нутри самой функции не юзаетьсться
}							t_replase_in_pars_42sh;

typedef struct				s_replase_in_exp_42sh//Структура для передачи параметров все изз-за долбанных норм
{
	unsigned char			*key;//добанная норма приходиться из-за нее клипать костыль на костыле//Чисто чтобы больше 5 переменых использовать//В нутри самой функции не юзаетьсться
	size_t					key_count;//добанная норма приходиться из-за нее клипать костыль на костыле//Чисто чтобы больше 5 переменых использовать//В нутри самой функции не юзаетьсться
	t_env_42sh				*env;//добанная норма приходиться из-за нее клипать костыль на костыле//Чисто чтобы больше 5 переменых использовать//В нутри самой функции не юзаетьсться
}							t_replase_in_exp_42sh;

typedef struct				s_replase_in_hrdc_42sh//Структура для передачи параметров все изз-за долбанных норм
{
	uint_fast8_t			b_test;//добанная норма приходиться из-за нее клипать костыль на костыле//Чисто чтобы больше 5 переменых использовать//В нутри самой функции не юзаетьсться
}							t_replase_in_hrdc_42sh;

typedef struct				s_replase_in_42sh//Структура для передачи параметров все изз-за долбанных норм
{
	t_main_42sh				*array;
	size_t					b_mode;//Определяет в каком режиме обрабатывать замену переноса строки в режиме аргументов или комманды
	t_replase_in_pars_42sh	prs;//Парсинг cmd
	t_replase_in_exp_42sh	exp;//Парсинг расширений переменных среды
	t_replase_in_hrdc_42sh	hrdc;//Парсинг хередок
}							t_replase_in_42sh;

typedef struct				s_overlow_byte_in_42sh//Структура для передачи параметров все изз-за долбанных норм
{
	char					*repl;//Указательна на хначение которое вставляем
	size_t					n_repl;//Размер нового значения которое вставляем
}							t_overlow_byte_in_42sh;

#endif
